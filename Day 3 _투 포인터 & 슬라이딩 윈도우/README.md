# 연속된 자연수의 합 구하기 백준 2018번
문제의 제한 시간은 2초. N의 최댓값은 10,000,000으로 O(n)의 시간 복잡도 알고리즘을 사용.<br/>
이 경우 투 포인터 방법을 쓴다.<br/>

투 포인터 이동 원칙<br/>
sum > N: sum = sum - start_index; start_index++;<br/>
sum < N: end_index++; sum = sum + end_index;<br/>
sum == N: end_index++; sum = sum + end_index; count++;<br/>


# 주몽의 명령 백준 1940번
N의 최대 범위가 15,000이므로 O(nlogn) 시간 복잡도를 사용하고 정렬 알고리즘의 시간 복잡도는 일반적으로 O(nlogn)이므로, 정렬 사용.<br/>
입력받은 N개의 재료값을 정렬한 다음 양쪽 끝의 위치를 투 포인터로 지정하는 방법을 쓴다.<br/>

투 포인터 이동 원칙<br/>
A[i] + A[j] > M: j--;   ## 번호의 합이 M보다 크므로 큰 번호 index를 내린다.<br/>
A[i] + A[j] < M: i++;   ## 번호의 합이 M보다 작으므로 작은 번호 index를 올린다.<br/>
A[i] + A[j] == M: i++; j--; count++;   ## 양쪽 포인터를 모두 이동시키고 count를 증가시킨다.<br/>

# 좋은 수 구하기 백준 1253번
N의 개수가 최대 2,000라 가정해도 N^2보다 작아야 한다. 따라서 좋은 수 하나를 찾는 알고리즘의 시간 복잡도는 최소 O(nlogn)이어야 하므로, 투 포인트를 사용한다.<br/>
단 정렬된 데이터에서 자기 자신을 좋은 수 만들기에 포함하면 안 된다.<br/>

투 포인터 이동 원칙
A[i] + A[j] > K: j--; A[i] + A[j] < K: i++;<br/>
A[i] + A[j] == K: count++; 프로세스 종료<br/>

# DNA 비밀번호 백준 12891번
1번 째 줄에 임의로 만든 DNA 문자열의 길이 |S|와 비밀번호로 사용할 부분 문자열의 길이 |P|가 주어진다 (1 <= |P| <= |S| <= 1,000,000).<br/>
2번 째 줄에 임의로 만든 DNA 문자열이 주어진다. 3번째 줄에 부분 문자열에 포함되어야 할 {'A', 'C', 'G', 'T'}의 최소 개수가 공백 문자를 사이에 두고 각각 주어진다.<br/>
각각의 수는 |S|보다 작거나 같은 음이 아닌 정수로 총합은 |S|보다 작거나 같다는 것이 보장된다.<br/>

# 최솟값 찾기 1 백준  11003번
N개의 수 A1, A2 ..., An과 L이 주어진다. Ai-L+1 ~ Ai 중 최솟값을 Di라고 할 때 D에 저장된 수를 출력하는 프로그램을 작성하시오.<br/>
이때 i <= 0 인 Ai는 무시하고 D를 구해야 한다.<br/>
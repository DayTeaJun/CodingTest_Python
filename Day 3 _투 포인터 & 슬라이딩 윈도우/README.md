# 연속된 자연수의 합 구하기 백준 2018번
문제의 제한 시간은 2초. N의 최댓값은 10,000,000으로 O(n)의 시간 복잡도 알고리즘을 사용.
이 경우 투 포인터 방법을 쓴다.

투 포인터 이동 원칙
sum > N: sum = sum - start_index; start_index++;
sum < N: end_index++; sum = sum + end_index;
sum == N: end_index++; sum = sum + end_index; count++;


# 주몽의 명령 백준 1940번
N의 최대 범위가 15,000이므로 O(nlogn) 시간 복잡도를 사용하고 정렬 알고리즘의 시간 복잡도는 일반적으로 O(nlogn)이므로, 정렬 사용.
입력받은 N개의 재료값을 정렬한 다음 양쪽 끝의 위치를 투 포인터로 지정하는 방법을 쓴다.

투 포인터 이동 원칙
A[i] + A[j] > M: j--;   ## 번호의 합이 M보다 크므로 큰 번호 index를 내린다.
A[i] + A[j] < M: i++;   ## 번호의 합이 M보다 작으므로 작은 번호 index를 올린다.
A[i] + A[j] == M: i++; j--; count++;   ## 양쪽 포인터를 모두 이동시키고 count를 증가시킨다.

# 좋은 수 구하기
N의 개수가 최대 2,000라 가정해도 N^2보다 작아야 한다. 따라서 좋은 수 하나를 찾는 알고리즘의 시간 복잡도는 최소 O(nlogn)이어야 하므로, 투 포인트를 사용한다.
단 정렬된 데이터에서 자기 자신을 좋은 수 만들기에 포함하면 안 된다.

투 포인터 이동 원칙
A[i] + A[j] > K: j--; A[i] + A[j] < K: i++;
A[i] + A[j] == K: count++; 프로세스 종료
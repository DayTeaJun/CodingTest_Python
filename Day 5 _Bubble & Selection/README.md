# 버블 정렬 O(n^2)
데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식  

* 버블 정렬 과정  
 - 비교 연산이 필요한 루프 범위를 설정한다.  
 - 인접한 데이터 값을 비교한다.  
 - swap 조건에 부합하면 swap 연산을 수행한다.  
 - 루프 범위가 끝날 때까지 위를 반복한다.  
 - 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.  
 - 비교 대상이 없을 때까지 위를 반복한다.  
 - swap이 한 번도 발생하지 않았다면 모두 정렬된 상태이다.


# 수 정렬하기 1 백준 2750번
문제  
N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

입력  
첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.

출력  
첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

# 버블 정렬 프로그램 1 백준 1377번
문제  
버블 소트 알고리즘을 다음과 같이 C++로 작성했다.  

bool changed = false;  
for (int i=1; i<=N+1; i++) {  
    changed = false;  
    for (int j=1; j<=N-i; j++) {  
        if (A[j] > A[j+1]) {  
            changed = true;  
            swap(A[j], A[j+1]);  
        }  
    }  
    if (changed == false) {  
        cout << i << '\n';  
        break;  
    }  
}  
위 소스에서 N은 배열의 크기이고, A는 정렬해야 하는 배열이다. 배열은 A[1]부터 사용한다.

위와 같은 소스를 실행시켰을 때, 어떤 값이 출력되는지 구해보자.

입력  
첫째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 A[1]부터 A[N]까지 하나씩 주어진다. A에 들어있는 수는 1,000,000보다 작거나 같은 자연수 또는 0이다.

출력  
정답을 출력한다.

# 선택 정렬 O(n^2)
대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방식  
효율적이지 않아 잘 안씀

* 선택 정렬 과정
 - 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
 - 남은 정렬 부분에서 가장 옆에 있는 데이터와 선택된 데이터를 swap한다.
 - 가장 앞에 있는 데이터의 위치를 변경해 남은 정렬 부분의 범위를 축소한다.
 - 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.

# 내림차순으로 자릿수 정렬하기 백준 1427번
문제  
배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.

입력  
첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.

출력  
첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.